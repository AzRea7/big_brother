from __future__ import annotations

from datetime import date, timedelta
from typing import Optional

from sqlalchemy.orm import Session
from sqlalchemy import select

from ..models import Task
from ..ai.llm import LLMClient


def _safe_due(days: int = 1) -> date:
    return date.today() + timedelta(days=days)


def _default_microtasks_for(task: Task) -> list[dict]:
    """
    Deterministic fallback if LLM unavailable.
    Splits a task into 2 microtasks that are always actionable.
    """
    base = task.title
    return [
        {
            "title": f"[MICRO] Starter for: {base}",
            "estimated_minutes": 10,
            "priority": min(5, task.priority),
            "blocks_me": True,
            "notes": (task.starter or "Open the relevant file and write the first 5 lines.") + "\n(Autogenerated microtask.)",
        },
        {
            "title": f"[MICRO] DoD push for: {base}",
            "estimated_minutes": 20,
            "priority": min(5, task.priority),
            "blocks_me": False,
            "notes": (task.dod or "Move it from 'started' to 'done' with a visible commit/test.") + "\n(Autogenerated microtask.)",
        },
    ]


async def generate_microtasks(db: Session, parent: Task, llm: Optional[LLMClient]) -> list[Task]:
    """
    Create 2 microtasks for a parent task.
    If LLM is enabled, ask it; otherwise use deterministic split.
    """
    # avoid duplicates: if already has children, do nothing
    existing = list(db.scalars(select(Task).where(Task.parent_task_id == parent.id)).all())
    if existing:
        return existing

    payloads: list[dict]
    if llm and llm.enabled():
        prompt = (
            "Create exactly 2 microtasks for this parent task.\n"
            "Rules:\n"
            "- Each microtask must be executable in <= 20 minutes.\n"
            "- Each must have a brutally specific 'Starter (2 min)' as first sentence.\n"
            "- Return JSON array only, with fields: title, estimated_minutes, priority, blocks_me, notes.\n\n"
            f"Parent title: {parent.title}\n"
            f"Parent notes: {parent.notes or ''}\n"
            f"Parent starter: {parent.starter or ''}\n"
            f"Parent DoD: {parent.dod or ''}\n"
        )
        try:
            text = await llm.generate(prompt)
            import json  # local import for safety
            payloads = json.loads(text)
            if not isinstance(payloads, list) or len(payloads) != 2:
                payloads = _default_microtasks_for(parent)
        except Exception:
            payloads = _default_microtasks_for(parent)
    else:
        payloads = _default_microtasks_for(parent)

    created: list[Task] = []
    for p in payloads:
        t = Task(
            goal_id=parent.goal_id,
            title=p["title"][:250],
            notes=p.get("notes"),
            due_date=_safe_due(1),
            priority=int(p.get("priority", parent.priority)),
            estimated_minutes=int(p.get("estimated_minutes", 15)),
            blocks_me=bool(p.get("blocks_me", False)),
            completed=False,
            project=parent.project,
            tags=parent.tags,
            link=parent.link,
            parent_task_id=parent.id,
            impact_score=parent.impact_score,
            confidence=parent.confidence,
            energy=parent.energy,
        )
        db.add(t)
        created.append(t)

    db.commit()
    for t in created:
        db.refresh(t)
    return created
